## 算法题
### KMP
### 迪利克雷
## 代码设计
### 设计模式
**创建型模式**，共五种：工厂方法模式、[抽象工厂模式](https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F "抽象工厂模式")、[单例模式](https://so.csdn.net/so/search?from=pc_blog_highlight&q=%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F "单例模式")、[建造者模式](https://so.csdn.net/so/search?q=%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020)、原型模式。

**结构型模式**，共七种：[适配器模式](https://so.csdn.net/so/search?q=%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020)、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

**行为型模式**，共十一种：策略模式、模板方法模式、[观察者模式](https://so.csdn.net/so/search?q=%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F&spm=1001.2101.3001.7020)、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
## c++
### 内存分配
malloc

在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。

　- 栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

　- 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。

　- 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。

　- 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的，在C++里面没有这个区分了，他们共同占用同一块内存区。

　- 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改。
### 重载、重写、覆盖
- 重载 overload
	- 同一个类中
	- 函数名相同
	- 参数不同
- 重写 override
	- 派生类与基类
	- 函数名相同
	- 参数相同
	- virtual关键字
- 覆盖 overwrite
	- 派生类与基类
	- 无virtual 或 参数不同
### 单例模式
```c++
#include <iostream>
#include <mutex>
 
class Singleton {
private:
    Singleton() {
        std::cout << "懒汉式 Singleton 构造函数" << std::endl;
    }
 
    static Singleton* instance;
    static std::mutex mtx;
 
public:
    static Singleton* getInstance() {
        if (instance == nullptr) {  // 第一次检查
            std::lock_guard<std::mutex> lock(mtx);  // 加锁
            if (instance == nullptr) {  // 第二次检查
                instance = new Singleton();
            }
        }
        return instance;
    }
 
    void showMessage() {
        std::cout << "线程安全的懒汉式单例" << std::endl;
    }
};
 
// 静态成员初始化
Singleton* Singleton::instance = nullptr;
std::mutex Singleton::mtx;
```
**优点：**
控制实例数量：确保全局只有一个实例，避免资源浪费。
全局访问：提供全局访问接口，方便统一管理资源。
延迟初始化：可以在首次调用时创建实例，节省系统资源。
**缺点：**
测试困难：由于单例是全局对象，可能会影响单元测试的独立性。
不易扩展：单例模式限制了继承和多态的使用，扩展性较差。
### 类
#### 空类自动生成的六个函数
- 构造函数
- 拷贝构造
- 析构函数
- 赋值运算
- 两个取址运算
### 三大特性
#### 继承
 继承是一指一个对象从另一个对象获得功能的过程，它提供了一种明确表述共性的方法。是一个不断向上抽取的过程

例如：所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。

继承与封装可以共同作用.如果一个给定的类封装了某些属性,它的任何子类将会继承同样得属性,另加各个子类所有得特有属性。
**好处：**
	1，提高了代码的复用性。
	2，让类与类之间产生了关系。有了这个关系，才有了多态的特性。
##### 对于公有继承方式

(1) 基类成员对其对象的可见性：　　  
公有成员可见，其他不可见。这里保护成员同于私有成员。  
(2) 基类成员对派生类的可见性：　　  
公有成员和保护成员可见，而私有成员不可见。这里保护成员同于公有成员。  
(3) 基类成员对派生类对象的可见性：　　  
公有成员可见，其他成员不可见。　　  
  
所以，在公有继承时，派生类的对象可以访问基类中的公有成员；派生类的成员函数可以访问基类中的公有成员和保护成员。这里，一定要区分清楚派生类的对象和派生类中的成员函数对基类的访问是不同的。

##### 对于私有继承方式

(1) 基类成员对其对象的可见性：　　  
公有成员可见，其他成员不可见。　　  
(2) 基类成员对派生类的可见性：　　  
公有成员和保护成员是可见的，而私有成员是不可见的。　　  
(3) 基类成员对派生类对象的可见性：　　  
所有成员都是不可见的。　　  
所以，在私有继承时，基类的成员只能由直接派生类访问，而无法再往下继承。

##### 对于保护继承方式

　　这种继承方式与私有继承方式的情况相同。两者的区别仅在于对派生类的成员而言，对基类成员有不同的可见性。　　上述所说的可见性也就是可访问性。关于可访问性还有另的一种说法。这种规则中，称派生类的对象对基类访问为水平访问，称派生类的派生类对基类的访问为垂直访问
#### 多态
基类中含有virtual 修饰的成员函数，编译器将在内存模型中的添加虚函数表的指针(vptr)，其占用sizeof(void \*)大小(跟平台相关)。该vptr指向存储在别处的虚函数表(vtbl)，vtbl中又存放着类中的[虚拟成员函数](https://zhida.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&zhida_source=entity&is_preview=1)的地址。
1. **虚函数表与成员变量无关**：虚函数表仅与虚函数的实现和调用相关，与成员变量（无论是否同名）没有直接关系。因此，成员变量的同名问题不会影响虚函数表的构建或虚函数的调用。
    
2. **虚函数的重写**：如果派生类重写了基类中的虚函数，那么派生类的虚函数表将包含指向派生类版本的虚函数指针。当通过基类指针或引用调用虚函数时，将根据实际对象的类型（即运行时类型）来确定调用哪个版本的函数。
    
3. **访问隐藏的基类成员变量**：如果需要在派生类中访问被隐藏的基类成员变量，可以使用作用域解析运算符（`::`）来明确指定要访问的变量所属的类。例如，如果基类`Base`和派生类`Derived`都有名为`value`的成员变量，那么在派生类中可以通过`Base::value`来访问基类中的`value`成员变量。
    
4. **多态性与虚函数表**：多态性允许通过基类类型的指针或引用来调用派生类中的成员函数，而具体调用哪个函数则是在运行时根据对象的实际类型来确定的。这种机制依赖于虚函数表和虚指针（vptr），它们共同工作以实现动态绑定。

- 如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址
- 如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址，但如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中


1，多态的体现
父类的引用指向了自己的子类对象。
父类的引用也可以接收自己的子类对象。
2，多态的前提
必须是类与类之间有关系。要么继承，要么实现。
通常还有一个前提：存在覆盖。
3，多态的好处
多态的出现大大的提高程序的扩展性。
4，多态的弊端
提高了扩展性，但是只能使用父类的引用访问父类中的成员。
##### 动态绑定与静态绑定
- 静态绑定：

绑定的是静态类型，比如函数依赖于对象的静态类型，发生在编译期。

- 动态绑定：

绑定的是动态类型，比如函数依赖于对象的动态类型，发生在运行期。

虚函数是动态绑定的，缺省参数是静态绑定的。
#### 封装——面向对象
面向对象，封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。
**好处：**
	1.将变化隔离；
	
	2.便于使用。
	
	3.提高重用性。
	
	4.提高安全性。
##### 友元函数
允许外面的类或函数去访问类的私有变量和保护变量，从而使两个类共享同一函数

优点：能够提高效率，表达简单、清晰 
缺点：友元函数破环了封装机制，尽量不使用成员函数，除非不得已的情况下才使用友元函数。
#### 泛型——为多态性服务
模板的工作原理主要是在编译时进行的。当你编写一个模板时，你并没有编写实际的代码，而是编写了一个“模板”或“蓝图”，它告诉编译器如何为特定的类型生成代码。当编译器遇到模板的实例化请求时（例如，调用一个模板函数或创建一个模板类的对象），它会根据提供的类型参数生成具体的代码。这个过程称为模板的实例化。

模板实例化可以发生在编译时的任何时间点，具体取决于编译器的实现和模板的使用方式。有时，编译器会延迟模板的实例化，直到需要它为止，这称为模板的惰性实例化。
#### STL

##### string
`std::string_view`是对字符串的一种非拥有式（non-owning）表示，意味着它不拥有字符串的内存，而是通过指针和长度来引用现有的字符串数据。
**轻量级**：std::string_view本身只包含一个指向字符串数据的指针和一个长度，因此它的大小非常小。
**非拥有式**：std::string_view不拥有字符串数据的内存，它只是对现有字符串数据的引用。这意味着它可以安全地引用临时字符串、字符串字面量或其他字符串对象，而无需复制数据。
零拷贝：由于std::string_view不拥有字符串数据，它可以在不进行数据复制的情况下对字符串进行操作。
**不可变性**：std::string_view是只读的，它提供了一系列成员函数来访问和操作字符串数据，但不能修改字符串的内容。
**字符串操作支持**：std::string_view提供了一组成员函数，例如data()、size()、empty()、substr()、compare()和find()等，使得对字符串数据的常见操作变得方便和高效。
https://blog.csdn.net/Long_xu/article/details/137569176
##### vector
###### resize
调整容器的大小，使其包含n个元素。

如果n小于当前容器的大小，则将内容减少到其前n个元素，并删除超出范围的元素（并销毁它们）。
如果n大于当前容器的大小，则通过在末尾插入所需数量的元素来扩展内容，以达到n的大小。如果指定了val，则将新元素初始化为val的副本，否则将对它们进行值初始化。
如果n也大于当前容器容量，将自动重新分配已分配的存储空间。
### 指针与引用区别
## 数据结构
### 栈和队列
#### 区别
操作的规则不同。

队列是先进先出（FIFO），即队列的修改是依先进先出的原则进行的。新来的成员总是加入队尾（不能从中间插入），每次离开的成员总是队列头上（不允许中途离队）。而栈为后进先出（LIFO）,即每次删除（出栈）的总是当前栈中最新的元素，即最后插入（进栈）的元素，而最先插入的被放在栈的底部，要到最后才能删除。

遍历数据速度不同。

队列是基于地址指针进行遍历，而且可以从头部或者尾部进行遍历，但不能同时遍历，无需开辟空间，因为在遍历的过程中不影响数据结构，所以遍历速度要快。栈是只能从顶部取数据，也就是说最先进入栈底的，需要遍历整个栈才能取出来，而且在遍历数据的同时需要为数据开辟临时空间，保持数据在遍历前的一致性。
#### 两个栈实现队列
https://blog.csdn.net/yzcllzx/article/details/137837687

## 计算机基础
### 进程、线程、协程
#### 1. 定义与概念

- **进程（Process）**：是操作系统进行资源分配的最小单位。进程是具有一定独立功能的程序关于某个数据集合的一次运行活动，是程序在处理器上顺序执行程序及其数据时发生的活动，是程序在数据集上运行的过程。它是一个独立的资源分配和调度单元，可以申请并拥有系统资源。
- **线程（Thread）**：是操作系统进行运算调度的最小单位，它是进程内部的一个执行路径，负责执行具体任务。线程与进程共享内存空间，并能够运行调用进程的所有资源（如CPU、内存等）。每个线程拥有独立的计数器、堆栈和局部变量等数据结构，它们共享相同的全局变量、静态变量以及动态分配的内存空间。
- **协程（Coroutine）**：是一种用户态的轻量级线程，它的调度是由用户控制的。协程的主要思想是在用户态实现的调度算法，用少量线程完成大量调度。一个线程可以有多个协程，一个进程也可以单独有多个协程。协程允许不同入口点在不同位置暂停或开始执行程序，具有非常高效的调度切换能力。

#### 2. 调度与并发

- **进程**：由于进程拥有独立的内存空间和系统资源，因此进程之间的切换需要较大的开销，包括保存和恢复进程的状态等。进程间的并发执行通常是通过操作系统的进程调度器来实现的，进程调度器会根据一定的调度算法（如先来先服务、短作业优先、时间片轮转等）来分配CPU时间给各个进程。
- **线程**：线程是轻量级的进程，它的创建、销毁、切换等操作都比进程快，而且开销更小。线程之间的切换通常只需要保存和恢复线程的上下文（如程序计数器、寄存器状态等），而不需要像进程那样保存和恢复整个进程的状态。因此，线程之间的并发执行更加高效。
- **协程**：协程的调度是由用户控制的，这意味着协程的切换可以在用户态下完成，而不需要操作系统介入。因此，协程的切换开销非常小，可以实现高效的并发执行。同时，由于协程的调度是由用户控制的，因此协程的并发执行更加灵活。

#### 3. 同步与异步

- **进程**和**线程**：进程和线程都是同步的，它们按照顺序执行程序代码，直到遇到I/O操作等需要等待的操作时才会暂停执行。在等待期间，CPU会切换到其他进程或线程执行。
- **协程**：协程是异步的，它可以在程序代码中指定挂起（yield）和恢复（resume）的点，从而实现非阻塞的并发执行。当协程遇到需要等待的操作时，它可以主动挂起自己并释放CPU资源，等待操作完成后再恢复执行。

#### 4. 资源共享与隔离

- **进程**：进程之间拥有独立的内存空间和系统资源，因此进程之间的数据是隔离的。进程间的通信需要通过特定的机制（如管道、消息队列、共享内存等）来实现。
- **线程**：线程之间共享进程的内存空间和系统资源，因此线程间的数据可以直接访问。但是，这也带来了线程间同步和互斥的问题，需要使用锁等同步机制来保证数据的一致性。独有栈空间，共享堆空间。
- **协程**：协程之间的资源共享和隔离取决于协程的实现方式和运行环境。在单线程环境中，协程之间的数据是共享的；但在多线程环境中，如果协程被分配到不同的线程中执行，那么协程之间的数据就需要通过特定的机制来同步和互斥。

综上所述，进程、线程和协程在定义、调度与并发、同步与异步以及资源共享与隔离等方面都存在显著的区别。在实际应用中，应根据具体需求选择合适的并发模型来实现高效、可靠的并发执行。


### 中断
![[Pasted image 20240910191726.png]]
### 进程间通信
1. **管道（Pipe）**：
    - 管道是一种最基本的IPC机制，它允许数据以字节流的形式，从一个进程的输出直接传输到另一个进程的输入。管道分为匿名管道和命名管道（有名管道FIFO）。匿名管道仅用于父子进程或兄弟进程之间的通信。
      我们知道管道是一端写出一段读取的，所以为了避免读写混乱我们只保留一个写入端描述符一个读取端描述符：父写子读
		- 父进程只保留写入的`fd[1]`,关闭读取的`fd[0]`
		- 子进程只保留读取的`fd[0]`,关闭写入的`fd[1]`
2. **消息队列（Message Queue）**：
    - 消息队列是消息的链接列表，存放在内核中并由消息队列标识符标识。它克服了管道传输数据无格式的缺点，具有消息边界，允许一个或多个进程向它写入或从中读取消息。
3. **信号（Signal）**：
    - 信号是软件中断的一种形式，用于通知进程发生了某种预先定义好的事件。进程可以处理接收到的信号，或者忽略它。信号主要用于通知接收进程某个事件已经发生。
    - 异步通信机制
4. **共享内存（Shared Memory）**：
    - 共享内存允许多个进程访问同一块内存区域，是最快的一种IPC方式，因为进程是直接对内存进行访问，不需要任何数据的复制。但需要注意同步和互斥问题，以防止数据不一致。
5. **信号量（Semaphore）**：
    - 信号量主要用于控制多个进程对共享资源的访问。它本质上是一个计数器，用于实现对共享资源的互斥访问。信号量不仅可以实现同步，还可以实现进程间的互斥。
6. **socket**
	服务端和客户端初始化socket，得到文件描述符
	服务端调用bind，将绑定在IP地址和端口
	服务端调用listen，进行监听
	服务端调用accept，等待客户端连接
	客户端调用connect，向服务器端的地址和端口发起连接请求
	服务端accept返回用于传输的socket的文件描述符
	客户端调用write写入数据，服务端read读取数据
	客户端断开连接时会调用close,那么服务端read读取数据时就会读取到EOF，在处理完数据后，服务器端调用close表示关闭连接。
## 计算机网络
### 拥塞控制
维护拥塞窗口的状态变量，动态变化
何时出现网络拥塞：未按时收到确认报文
慢开始门限 状态变量

#### 慢开始

拥塞窗口变化2-4-8
到达慢开始门限后，使用拥塞避免
#### 拥塞避免
8-9-10

#### 快重传
三个重复确认，则立即重传
#### 快恢复
门限/2 继续拥塞避免
### 流量控制
接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量 win 来表示接收窗口的大小。发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发


### 协议
#### TCP/IP 协议簇
ICMP是 Internet Control Message Protocol 的缩写，即[互联网控制消息协议](https://zhida.zhihu.com/search?q=%E4%BA%92%E8%81%94%E7%BD%91%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE&zhida_source=entity&is_preview=1)。它是互联网协议族的核心协议之一。它用于 TCP/IP 网络中发送控制消息，提供可能发生在通信环境中的各种问题反馈，通过这些信息，使[网络管理者](https://zhida.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E8%80%85&zhida_source=entity&is_preview=1)可以对所发生的问题作出诊断，然后采取适当的措施解决问题。IP协议直接提供服务

TCP 21端口：FTP 文件传输服务

TCP 23端口：TELNET 终端仿真服务

TCP 25端口：SMTP 简单邮件传输服务

UDP 53端口：DNS 域名解析服务

TCP 80端口：HTTP 超文本传输服务

TCP 110端口：POP3 “邮局协议版本3”使用的端口

TCP 443端口：HTTPS 加密的超文本传输服务

TCP 1521端口：Oracle数据库服务

TCP 1863端口：MSN Messenger的文件传输功能所使用的端口

TCP 3389端口：Microsoft RDP 微软远程桌面使用的端口

TCP 5631端口：Symantec pcAnywhere 远程控制数据传输时使用的端口

UDP 5632端口：Symantec pcAnywhere 主控端扫描被控端时使用的端口

TCP 5000端口：MS SQL Server使用的端口

UDP 8000端口：腾讯QQ

### 数据链路层
网桥连接的两个网络，在特定条件下，可以采用不同的网络协议和配置。具体来说，网桥能够互联两个采用不同**数据链路层协议**和**物理层协议**的网络。以下是详细解释：

### http协议
#### 请求返回流程

一、HTTP请求报文的发送

1. **建立连接**：
    - 客户端（如浏览器）通过TCP/IP协议与服务器建立连接。HTTP是基于TCP协议的，因此在发送HTTP请求之前，需要建立TCP连接。
2. **发送请求**：
    - 客户端构造HTTP请求报文，并将其发送给服务器。HTTP请求报文主要由请求行、请求头部（Header）和请求体（Body，可选）三个部分组成。
        - **请求行**：包含HTTP方法（如GET、POST等）、请求的资源路径（URL）以及HTTP版本信息（如HTTP/1.1）。
        - **请求头部**：包含了一系列字段，用于描述客户端信息、请求条件等，如Host（目标主机名）、User-Agent（用户代理，如浏览器类型、版本等）、Accept（客户端可以处理的媒体类型）、Accept-Language（客户端的语言偏好）、Cookie（用于存储和传递会话信息）等。
        - **请求体**：可选部分，用于包含客户端发送给服务器的数据。在POST请求中，请求体通常包含表单数据、JSON数据等。
3. **请求报文的格式**：
    - `Method Request-URI HTTP-Version CRLF`
    - `headers CRLF`
    - `[message-body]`

二、HTTP响应报文的返回

1. **处理请求**：
    - 服务器接收到客户端的请求后，会根据请求报文的内容进行相应的处理，如查询数据库、生成页面等。
2. **生成响应**：
    - 服务器处理完请求后，会生成HTTP响应报文。HTTP响应报文主要由状态行、响应头部（Header）和响应体（Body，可选）三个部分组成。
        - **状态行**：包含HTTP版本、状态码和状态消息。状态码用于表示请求的结果，如200 OK表示请求成功，404 Not Found表示请求的资源不存在，500 Internal Server Error表示服务器内部错误。
        - **响应头部**：与请求头部类似，也包含了一系列字段，用于描述服务器的信息、响应条件等，如Content-Type（响应体的媒体类型）、Content-Length（响应体的长度）、Server（服务器的类型和版本）、Set-Cookie（用于设置会话信息）等。
        - **响应体**：可选部分，包含了服务器返回给客户端的数据。这些数据可以是HTML页面、图片、JSON数据等，具体取决于请求的资源类型和服务器的处理逻辑。
3. **发送响应**：
    - 服务器将生成的HTTP响应报文发送给客户端。
4. **响应报文的格式**：
    - `HTTP-Version Status-Code Reason-Phrase CRLF`
    - `headers CRLF`
    - `[message-body]`

三、连接关闭（可选）

- 在HTTP/1.0中，每个请求/响应都需要建立一个新的连接，请求结束后连接会被关闭。但在HTTP/1.1中，引入了持久连接（也称为长连接）的概念，允许多个请求/响应在同一个连接上发送，以提高效率。

通过以上步骤，HTTP协议实现了客户端与服务器之间的数据交互。这一过程构成了HTTP协议从请求到响应的全过程，为互联网上的各种应用提供了基础支持。
## 操作系统
### 内存对齐
CPU按块来进行内存读取，用空间换取时间
### 上下文切换
一般指CPU上下文切换，多任务运行，前一个任务保存，加载新任务继续运行（CPU寄存器和程序计数器）
#### 进程上下文切换
进程切换只能发生在内核态
用户态资源保存，切换内核态，保存内核态资源，加载下一进程内核态，切换为用户态后，刷新进程资源
#### 线程上下文切换
1. 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。
2. 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据
#### 中断上下文切换
响应事件，所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。
### 页面置换
**最佳置换(OPT)算法**选择的被淘汰页面，将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面；采用最佳置换算法可保证获得最低的缺页率。但是由于无法预知哪一个页面是未来最长时间内不再被访问的，因而该算法是无法实现的；

**先进先出（FIFO）算法**淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。

**最近最久未使用（LRU）算法**根据页面调入内存后的使用情况进行决策，选择最近最久未使用的页面予以淘汰；该算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问一来所经历的时间T，当需要淘汰一个页面时，选择现有页面中T值最大的，即最近最久未使用的页面予以淘汰。

**CLOCK算法**又称为最近未使用算法（NUR） 每页设置一个访问位，再将内存中的所有页面都通过链接指针链接成一个循环队列；当某个页面被访问时，其访问位置1。淘汰时，检查其访问位，如果是0，就换出；若为1，则重新将它置0；再按FIFO算法检查下一个页面，到队列中的最后一个页面时，若其访问位仍为1，则再返回到队首再去检查第一个页面。
### 行存与列存
**行存储方式（Row-major order）:**
数组元素按行顺序存储在内存中。
对于二维数组 N[i][j]，元素 N[i][j] 的地址计算公式为： N[i][j] =BaseAddress + (i \*列数+ j) \*元素大小
这是 C/C++、Java、Python 等多数编程语言采用的默认方式。
**列存储方式（Column-major order）:**
数组元素按列顺序存储在内存中。
对于二维数组 N[i][j]，元素 N[i][j] 的地址计算公式为： N[i][j] = BaseAddress + (j * 行数 + i) * 元素大小
这是 Fortran 和 MATLAB 等语言采用的方式。
### 中断和异常
外中断——就是我们指的中断——是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等；为了**支持CPU和设备之间的并行操作**
内中断——就是异常——是指由于 CPU 内部事件所引起的中断，如程序出错(非法指令、地址越界)。内中断(trap)也被译为“捕获”或“陷入”。
异常是由于执行了现行指令所引起的。由于系统调用引起的中断属于异常。表示**CPU执行指令时本身出现的问题**
中断则是由于系统中某事件引起的，该事件与现行指令无关

### GDB
Core dump 是指在程序异常终止时，操作系统将程序的内存映像保存到磁盘上的一种机制。

**操作系统**：操作系统负责内存管理和进程控制。当程序尝试访问无效内存地址时，操作系统通过其内存管理机制（如页表保护）检测到这一行为。操作系统会响应这种违规访问，通常是通过发送一个信号（如SIGSEGV，即Segmentation Violation信号）给违规的进程
**信号接受与处理**
1. **信号接收**：当进程接收到SIGSEGV信号时，它可以有几种响应方式：
    - **默认行为**：大多数系统对SIGSEGV的默认行为是终止进程，并生成core dump（如果core dump被启用）。
    - **捕获信号**：进程可以通过安装信号处理程序（signal handler）来捕获SIGSEGV信号。在信号处理程序中，进程可以执行清理操作，然后正常退出或采取其他恢复措施（尽管对于SIGSEGV，恢复通常是不安全的）。
2. **core dump生成**：当进程因SIGSEGV等致命信号而终止时，如果系统配置允许，操作系统会生成一个core dump文件。这个文件包含了程序崩溃时的内存映像、寄存器状态等信息，可以用于后续的分析和调试。
### IO多路复用
1. 阻塞IO
2. 非阻塞IO
3. IO多路复用
4. 信号驱动IO
5. 异步IO

select
三组文件描述符
readfds是需要进行读操作的[文件描述符](https://zhida.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6&zhida_source=entity&is_preview=1)，writefds是需要进行写操作的文件描述符，exceptfds是需要进行[异常事件](https://link.zhihu.com/?target=http%3A//man7.org/linux/man-pages/man2/poll.2.html)处理的文件描述符
epoll

poll
### 缓存
在高并发系统中，缓存是提升系统性能的重要手段之一。然而，缓存穿透是一个常见的问题，它指的是查询一个缓存中和数据库中都不存在的数据，导致每次查询都会穿透缓存直接查询数据库，进而对数据库造成巨大压力。为了应对缓存穿透，我们可以采取以下几种优化策略：

#### 1. 缓存空对象

- **原理**：当数据库中查不到数据时，我们缓存一个空对象（null或者特定的空值标识），并设置合理的过期时间。这样，当再次查询这个不存在的数据时，就可以直接从缓存中获取空对象，而不是去查询数据库。
- **优点**：实现简单，能有效减少数据库的查询压力。
- **缺点**：需要缓存层提供更多的内存空间来缓存这些空对象，且可能导致缓存层和存储层的数据不一致（尽管设置了较短的过期时间）。

#### 2. 布隆过滤器拦截

- **原理**：布隆过滤器是一种数据结构，由一个长度为m的位数组和n个哈希函数组成。它用于判断一个元素是否在一个集合中，但存在误判率。在查询缓存之前，先通过布隆过滤器判断该数据是否存在。如果不存在，则直接返回，不再查询缓存和数据库。
- **优点**：内存占用少，查询效率高，能有效减少不必要的缓存和数据库查询。
- **缺点**：存在误判率，即可能将不存在的数据误判为存在，但误判为不存在的数据是一定不存在的。此外，布隆过滤器不支持删除操作。


### 数据结构

#### 树
##### 哈夫曼树

用于前缀编码，保证电文总长最短

要设计长度不等的编码，则必须使任一字符的编码都不是另一个字符的编码的前缀





