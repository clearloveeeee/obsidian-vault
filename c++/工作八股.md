# 算法题
## KMP
## 迪利克雷
## c++
### 三大特性
#### 继承
 继承是一指一个对象从另一个对象获得功能的过程，它提供了一种明确表述共性的方法。是一个不断向上抽取的过程

例如：所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。

继承与封装可以共同作用.如果一个给定的类封装了某些属性,它的任何子类将会继承同样得属性,另加各个子类所有得特有属性。
**好处：**
	1，提高了代码的复用性。
	2，让类与类之间产生了关系。有了这个关系，才有了多态的特性。
##### 对于公有继承方式

(1) 基类成员对其对象的可见性：　　  
公有成员可见，其他不可见。这里保护成员同于私有成员。  
(2) 基类成员对派生类的可见性：　　  
公有成员和保护成员可见，而私有成员不可见。这里保护成员同于公有成员。  
(3) 基类成员对派生类对象的可见性：　　  
公有成员可见，其他成员不可见。　　  
  
所以，在公有继承时，派生类的对象可以访问基类中的公有成员；派生类的成员函数可以访问基类中的公有成员和保护成员。这里，一定要区分清楚派生类的对象和派生类中的成员函数对基类的访问是不同的。

##### 对于私有继承方式

(1) 基类成员对其对象的可见性：　　  
公有成员可见，其他成员不可见。　　  
(2) 基类成员对派生类的可见性：　　  
公有成员和保护成员是可见的，而私有成员是不可见的。　　  
(3) 基类成员对派生类对象的可见性：　　  
所有成员都是不可见的。　　  
所以，在私有继承时，基类的成员只能由直接派生类访问，而无法再往下继承。

##### 对于保护继承方式

　　这种继承方式与私有继承方式的情况相同。两者的区别仅在于对派生类的成员而言，对基类成员有不同的可见性。　　上述所说的可见性也就是可访问性。关于可访问性还有另的一种说法。这种规则中，称派生类的对象对基类访问为水平访问，称派生类的派生类对基类的访问为垂直访问
#### 多态
基类中含有virtual 修饰的成员函数，编译器将在内存模型中的添加虚函数表的指针(vptr)，其占用sizeof(void \*)大小(跟平台相关)。该vptr指向存储在别处的虚函数表(vtbl)，vtbl中又存放着类中的[虚拟成员函数](https://zhida.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&zhida_source=entity&is_preview=1)的地址。
1. **虚函数表与成员变量无关**：虚函数表仅与虚函数的实现和调用相关，与成员变量（无论是否同名）没有直接关系。因此，成员变量的同名问题不会影响虚函数表的构建或虚函数的调用。
    
2. **虚函数的重写**：如果派生类重写了基类中的虚函数，那么派生类的虚函数表将包含指向派生类版本的虚函数指针。当通过基类指针或引用调用虚函数时，将根据实际对象的类型（即运行时类型）来确定调用哪个版本的函数。
    
3. **访问隐藏的基类成员变量**：如果需要在派生类中访问被隐藏的基类成员变量，可以使用作用域解析运算符（`::`）来明确指定要访问的变量所属的类。例如，如果基类`Base`和派生类`Derived`都有名为`value`的成员变量，那么在派生类中可以通过`Base::value`来访问基类中的`value`成员变量。
    
4. **多态性与虚函数表**：多态性允许通过基类类型的指针或引用来调用派生类中的成员函数，而具体调用哪个函数则是在运行时根据对象的实际类型来确定的。这种机制依赖于虚函数表和虚指针（vptr），它们共同工作以实现动态绑定。



- 如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址
- 如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址，但如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中


1，多态的体现
父类的引用指向了自己的子类对象。
父类的引用也可以接收自己的子类对象。
2，多态的前提
必须是类与类之间有关系。要么继承，要么实现。
通常还有一个前提：存在覆盖。
3，多态的好处
多态的出现大大的提高程序的扩展性。
4，多态的弊端
提高了扩展性，但是只能使用父类的引用访问父类中的成员。
虚表
#### 封装——面向对象
面向对象，封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。
**好处：**
	1.将变化隔离；
	
	2.便于使用。
	
	3.提高重用性。
	
	4.提高安全性。
#### 泛型——为多态性服务
模板的工作原理主要是在编译时进行的。当你编写一个模板时，你并没有编写实际的代码，而是编写了一个“模板”或“蓝图”，它告诉编译器如何为特定的类型生成代码。当编译器遇到模板的实例化请求时（例如，调用一个模板函数或创建一个模板类的对象），它会根据提供的类型参数生成具体的代码。这个过程称为模板的实例化。

模板实例化可以发生在编译时的任何时间点，具体取决于编译器的实现和模板的使用方式。有时，编译器会延迟模板的实例化，直到需要它为止，这称为模板的惰性实例化。
#### STL

##### string
`std::string_view`是对字符串的一种非拥有式（non-owning）表示，意味着它不拥有字符串的内存，而是通过指针和长度来引用现有的字符串数据。
**轻量级**：std::string_view本身只包含一个指向字符串数据的指针和一个长度，因此它的大小非常小。
**非拥有式**：std::string_view不拥有字符串数据的内存，它只是对现有字符串数据的引用。这意味着它可以安全地引用临时字符串、字符串字面量或其他字符串对象，而无需复制数据。
零拷贝：由于std::string_view不拥有字符串数据，它可以在不进行数据复制的情况下对字符串进行操作。
**不可变性**：std::string_view是只读的，它提供了一系列成员函数来访问和操作字符串数据，但不能修改字符串的内容。
**字符串操作支持**：std::string_view提供了一组成员函数，例如data()、size()、empty()、substr()、compare()和find()等，使得对字符串数据的常见操作变得方便和高效。
https://blog.csdn.net/Long_xu/article/details/137569176
##### vector
###### resize
调整容器的大小，使其包含n个元素。

如果n小于当前容器的大小，则将内容减少到其前n个元素，并删除超出范围的元素（并销毁它们）。
如果n大于当前容器的大小，则通过在末尾插入所需数量的元素来扩展内容，以达到n的大小。如果指定了val，则将新元素初始化为val的副本，否则将对它们进行值初始化。
如果n也大于当前容器容量，将自动重新分配已分配的存储空间。
## 计算机基础
### 进程、线程、协程
#### 1. 定义与概念

- **进程（Process）**：是操作系统进行资源分配的最小单位。进程是具有一定独立功能的程序关于某个数据集合的一次运行活动，是程序在处理器上顺序执行程序及其数据时发生的活动，是程序在数据集上运行的过程。它是一个独立的资源分配和调度单元，可以申请并拥有系统资源。
- **线程（Thread）**：是操作系统进行运算调度的最小单位，它是进程内部的一个执行路径，负责执行具体任务。线程与进程共享内存空间，并能够运行调用进程的所有资源（如CPU、内存等）。每个线程拥有独立的计数器、堆栈和局部变量等数据结构，它们共享相同的全局变量、静态变量以及动态分配的内存空间。
- **协程（Coroutine）**：是一种用户态的轻量级线程，它的调度是由用户控制的。协程的主要思想是在用户态实现的调度算法，用少量线程完成大量调度。一个线程可以有多个协程，一个进程也可以单独有多个协程。协程允许不同入口点在不同位置暂停或开始执行程序，具有非常高效的调度切换能力。

#### 2. 调度与并发

- **进程**：由于进程拥有独立的内存空间和系统资源，因此进程之间的切换需要较大的开销，包括保存和恢复进程的状态等。进程间的并发执行通常是通过操作系统的进程调度器来实现的，进程调度器会根据一定的调度算法（如先来先服务、短作业优先、时间片轮转等）来分配CPU时间给各个进程。
- **线程**：线程是轻量级的进程，它的创建、销毁、切换等操作都比进程快，而且开销更小。线程之间的切换通常只需要保存和恢复线程的上下文（如程序计数器、寄存器状态等），而不需要像进程那样保存和恢复整个进程的状态。因此，线程之间的并发执行更加高效。
- **协程**：协程的调度是由用户控制的，这意味着协程的切换可以在用户态下完成，而不需要操作系统介入。因此，协程的切换开销非常小，可以实现高效的并发执行。同时，由于协程的调度是由用户控制的，因此协程的并发执行更加灵活。

#### 3. 同步与异步

- **进程**和**线程**：进程和线程都是同步的，它们按照顺序执行程序代码，直到遇到I/O操作等需要等待的操作时才会暂停执行。在等待期间，CPU会切换到其他进程或线程执行。
- **协程**：协程是异步的，它可以在程序代码中指定挂起（yield）和恢复（resume）的点，从而实现非阻塞的并发执行。当协程遇到需要等待的操作时，它可以主动挂起自己并释放CPU资源，等待操作完成后再恢复执行。

#### 4. 资源共享与隔离

- **进程**：进程之间拥有独立的内存空间和系统资源，因此进程之间的数据是隔离的。进程间的通信需要通过特定的机制（如管道、消息队列、共享内存等）来实现。
- **线程**：线程之间共享进程的内存空间和系统资源，因此线程间的数据可以直接访问。但是，这也带来了线程间同步和互斥的问题，需要使用锁等同步机制来保证数据的一致性。独有栈空间，共享堆空间。
- **协程**：协程之间的资源共享和隔离取决于协程的实现方式和运行环境。在单线程环境中，协程之间的数据是共享的；但在多线程环境中，如果协程被分配到不同的线程中执行，那么协程之间的数据就需要通过特定的机制来同步和互斥。

综上所述，进程、线程和协程在定义、调度与并发、同步与异步以及资源共享与隔离等方面都存在显著的区别。在实际应用中，应根据具体需求选择合适的并发模型来实现高效、可靠的并发执行。


### 中断
![[Pasted image 20240910191726.png]]
### 进程间通信
1. **管道（Pipe）**：
    - 管道是一种最基本的IPC机制，它允许数据以字节流的形式，从一个进程的输出直接传输到另一个进程的输入。管道分为匿名管道和命名管道（有名管道FIFO）。匿名管道仅用于父子进程或兄弟进程之间的通信。
2. **消息队列（Message Queue）**：
    - 消息队列是消息的链接列表，存放在内核中并由消息队列标识符标识。它克服了管道传输数据无格式的缺点，具有消息边界，允许一个或多个进程向它写入或从中读取消息。
3. **信号（Signal）**：
    - 信号是软件中断的一种形式，用于通知进程发生了某种预先定义好的事件。进程可以处理接收到的信号，或者忽略它。信号主要用于通知接收进程某个事件已经发生。
4. **共享内存（Shared Memory）**：
    - 共享内存允许多个进程访问同一块内存区域，是最快的一种IPC方式，因为进程是直接对内存进行访问，不需要任何数据的复制。但需要注意同步和互斥问题，以防止数据不一致。
5. **信号量（Semaphore）**：
    - 信号量主要用于控制多个进程对共享资源的访问。它本质上是一个计数器，用于实现对共享资源的互斥访问。信号量不仅可以实现同步，还可以实现进程间的互斥。
## 计算机网络
### 拥塞控制
维护拥塞窗口的状态变量，动态变化
何时出现网络拥塞：未按时收到确认报文
慢开始门限 状态变量

#### 慢开始

拥塞窗口变化2-4-8
到达慢开始门限后，使用拥塞避免
#### 拥塞避免
8-9-10

#### 快重传
三个重复确认，则立即重传
#### 快恢复
门限/2 继续拥塞避免
### 流量控制
接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量 win 来表示接收窗口的大小。发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发


## 操作系统
### 行存与列存
**行存储方式（Row-major order）:**
数组元素按行顺序存储在内存中。
对于二维数组 N[i][j]，元素 N[i][j] 的地址计算公式为： N[i][j] =BaseAddress + (i \*列数+ j) \*元素大小
这是 C/C++、Java、Python 等多数编程语言采用的默认方式。
**列存储方式（Column-major order）:**
数组元素按列顺序存储在内存中。
对于二维数组 N[i][j]，元素 N[i][j] 的地址计算公式为： N[i][j] = BaseAddress + (j * 行数 + i) * 元素大小
这是 Fortran 和 MATLAB 等语言采用的方式。


### GDB
Core dump 是指在程序异常终止时，操作系统将程序的内存映像保存到磁盘上的一种机制。

**操作系统**：操作系统负责内存管理和进程控制。当程序尝试访问无效内存地址时，操作系统通过其内存管理机制（如页表保护）检测到这一行为。操作系统会响应这种违规访问，通常是通过发送一个信号（如SIGSEGV，即Segmentation Violation信号）给违规的进程
**信号接受与处理**
1. **信号接收**：当进程接收到SIGSEGV信号时，它可以有几种响应方式：
    - **默认行为**：大多数系统对SIGSEGV的默认行为是终止进程，并生成core dump（如果core dump被启用）。
    - **捕获信号**：进程可以通过安装信号处理程序（signal handler）来捕获SIGSEGV信号。在信号处理程序中，进程可以执行清理操作，然后正常退出或采取其他恢复措施（尽管对于SIGSEGV，恢复通常是不安全的）。
2. **core dump生成**：当进程因SIGSEGV等致命信号而终止时，如果系统配置允许，操作系统会生成一个core dump文件。这个文件包含了程序崩溃时的内存映像、寄存器状态等信息，可以用于后续的分析和调试。
### IO多路复用
1. 阻塞IO
2. 非阻塞IO
3. IO多路复用
4. 信号驱动IO
5. 异步IO

select
三组文件描述符
readfds是需要进行读操作的[文件描述符](https://zhida.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6&zhida_source=entity&is_preview=1)，writefds是需要进行写操作的文件描述符，exceptfds是需要进行[异常事件](https://link.zhihu.com/?target=http%3A//man7.org/linux/man-pages/man2/poll.2.html)处理的文件描述符
epoll

poll






