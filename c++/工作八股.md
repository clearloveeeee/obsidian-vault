# 算法题
## KMP
## 迪利克雷
## c++
### 三大特性
#### 继承
 继承是一指一个对象从另一个对象获得功能的过程，它提供了一种明确表述共性的方法。是一个不断向上抽取的过程

例如：所有的Windows应用程序都有一个窗口，它们可以看作都是从一个窗口类派生出来的。但是有的应用程序用于文字处理，有的应用程序用于绘图，这是由于派生出了不同的子类，各个子类添加了不同的特性。

继承与封装可以共同作用.如果一个给定的类封装了某些属性,它的任何子类将会继承同样得属性,另加各个子类所有得特有属性。
**好处：**
	1，提高了代码的复用性。
	2，让类与类之间产生了关系。有了这个关系，才有了多态的特性。
#### 多态
基类中含有virtual 修饰的成员函数，编译器将在内存模型中的添加虚函数表的指针(vptr)，其占用sizeof(void \*)大小(跟平台相关)。该vptr指向存储在别处的虚函数表(vtbl)，vtbl中又存放着类中的[虚拟成员函数](https://zhida.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0&zhida_source=entity&is_preview=1)的地址。
- 如果派生类重写了基类的虚方法，该派生类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址
- 如果基类中的虚方法没有在派生类中重写，那么派生类将继承基类中的虚方法，而且派生类中虚函数表将保存基类中未被重写的虚函数的地址，但如果派生类中定义了新的虚方法，则该虚函数的地址也将被添加到派生类虚函数表中
1，多态的体现
父类的引用指向了自己的子类对象。
父类的引用也可以接收自己的子类对象。
2，多态的前提
必须是类与类之间有关系。要么继承，要么实现。
通常还有一个前提：存在覆盖。
3，多态的好处
多态的出现大大的提高程序的扩展性。
4，多态的弊端
提高了扩展性，但是只能使用父类的引用访问父类中的成员。
#### 封装——面向对象
面向对象，封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。一旦定义了一个对象的特性，则有必要决定这些特性的可见性，即哪些特性对外部世界是可见的，哪些特性用于表示内部状态。在这个阶段定义对象的接口。通常，应禁止直接访问一个对象的实际表示，而应通过操作接口访问对象，这称为信息隐藏。事实上，信息隐藏是用户对封装性的认识，封装则为信息隐藏提供支持。封装保证了模块具有较好的独立性，使得程序维护修改较为容易。对应用程序的修改仅限于类的内部，因而可以将应用程序修改带来的影响减少到最低限度。
**好处：**
	1.将变化隔离；
	
	2.便于使用。
	
	3.提高重用性。
	
	4.提高安全性。
### 泛型
## 计算机基础
### 进程、线程、协程
#### 1. 定义与概念

- **进程（Process）**：是操作系统进行资源分配的最小单位。进程是具有一定独立功能的程序关于某个数据集合的一次运行活动，是程序在处理器上顺序执行程序及其数据时发生的活动，是程序在数据集上运行的过程。它是一个独立的资源分配和调度单元，可以申请并拥有系统资源。
- **线程（Thread）**：是操作系统进行运算调度的最小单位，它是进程内部的一个执行路径，负责执行具体任务。线程与进程共享内存空间，并能够运行调用进程的所有资源（如CPU、内存等）。每个线程拥有独立的计数器、堆栈和局部变量等数据结构，它们共享相同的全局变量、静态变量以及动态分配的内存空间。
- **协程（Coroutine）**：是一种用户态的轻量级线程，它的调度是由用户控制的。协程的主要思想是在用户态实现的调度算法，用少量线程完成大量调度。一个线程可以有多个协程，一个进程也可以单独有多个协程。协程允许不同入口点在不同位置暂停或开始执行程序，具有非常高效的调度切换能力。

#### 2. 调度与并发

- **进程**：由于进程拥有独立的内存空间和系统资源，因此进程之间的切换需要较大的开销，包括保存和恢复进程的状态等。进程间的并发执行通常是通过操作系统的进程调度器来实现的，进程调度器会根据一定的调度算法（如先来先服务、短作业优先、时间片轮转等）来分配CPU时间给各个进程。
- **线程**：线程是轻量级的进程，它的创建、销毁、切换等操作都比进程快，而且开销更小。线程之间的切换通常只需要保存和恢复线程的上下文（如程序计数器、寄存器状态等），而不需要像进程那样保存和恢复整个进程的状态。因此，线程之间的并发执行更加高效。
- **协程**：协程的调度是由用户控制的，这意味着协程的切换可以在用户态下完成，而不需要操作系统介入。因此，协程的切换开销非常小，可以实现高效的并发执行。同时，由于协程的调度是由用户控制的，因此协程的并发执行更加灵活。

#### 3. 同步与异步

- **进程**和**线程**：进程和线程都是同步的，它们按照顺序执行程序代码，直到遇到I/O操作等需要等待的操作时才会暂停执行。在等待期间，CPU会切换到其他进程或线程执行。
- **协程**：协程是异步的，它可以在程序代码中指定挂起（yield）和恢复（resume）的点，从而实现非阻塞的并发执行。当协程遇到需要等待的操作时，它可以主动挂起自己并释放CPU资源，等待操作完成后再恢复执行。

#### 4. 资源共享与隔离

- **进程**：进程之间拥有独立的内存空间和系统资源，因此进程之间的数据是隔离的。进程间的通信需要通过特定的机制（如管道、消息队列、共享内存等）来实现。
- **线程**：线程之间共享进程的内存空间和系统资源，因此线程间的数据可以直接访问。但是，这也带来了线程间同步和互斥的问题，需要使用锁等同步机制来保证数据的一致性。独有栈空间，共享堆空间。
- **协程**：协程之间的资源共享和隔离取决于协程的实现方式和运行环境。在单线程环境中，协程之间的数据是共享的；但在多线程环境中，如果协程被分配到不同的线程中执行，那么协程之间的数据就需要通过特定的机制来同步和互斥。

综上所述，进程、线程和协程在定义、调度与并发、同步与异步以及资源共享与隔离等方面都存在显著的区别。在实际应用中，应根据具体需求选择合适的并发模型来实现高效、可靠的并发执行。


### 中断
![[Pasted image 20240910191726.png]]
### 进程间通信
1. **管道（Pipe）**：
    - 管道是一种最基本的IPC机制，它允许数据以字节流的形式，从一个进程的输出直接传输到另一个进程的输入。管道分为匿名管道和命名管道（有名管道FIFO）。匿名管道仅用于父子进程或兄弟进程之间的通信。
2. **消息队列（Message Queue）**：
    - 消息队列是消息的链接列表，存放在内核中并由消息队列标识符标识。它克服了管道传输数据无格式的缺点，具有消息边界，允许一个或多个进程向它写入或从中读取消息。
3. **信号（Signal）**：
    - 信号是软件中断的一种形式，用于通知进程发生了某种预先定义好的事件。进程可以处理接收到的信号，或者忽略它。信号主要用于通知接收进程某个事件已经发生。
4. **共享内存（Shared Memory）**：
    - 共享内存允许多个进程访问同一块内存区域，是最快的一种IPC方式，因为进程是直接对内存进行访问，不需要任何数据的复制。但需要注意同步和互斥问题，以防止数据不一致。
5. **信号量（Semaphore）**：
    - 信号量主要用于控制多个进程对共享资源的访问。它本质上是一个计数器，用于实现对共享资源的互斥访问。信号量不仅可以实现同步，还可以实现进程间的互斥。
## 计算机网络
### 拥塞控制
维护拥塞窗口的状态变量，动态变化
何时出现网络拥塞：未按时收到确认报文
慢开始门限 状态变量

#### 慢开始

拥塞窗口变化2-4-8
到达慢开始门限后，使用拥塞避免
#### 拥塞避免
8-9-10

#### 快重传
三个重复确认，则立即重传
#### 快恢复
门限/2 继续拥塞避免
### 流量控制
接收方每次收到数据包，可以在发送确定报文的时候，同时告诉发送方自己的缓存区还剩余多少是空闲的，我们也把缓存区的剩余大小称之为接收窗口大小，用变量 win 来表示接收窗口的大小。发送方收到之后，便会调整自己的发送速率，也就是调整自己发送窗口的大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据，防止出现大量丢包情况的发
