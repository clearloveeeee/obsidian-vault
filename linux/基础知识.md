## 动态库和静态库
### 动态库
lib*.so
lib*.dll
gcc进行链接时，动态库代码不会加入
### 静态库
linux : lib*.a
gcc进行链接是，静态库代码加入
### 静态库动态库对比
  
预处理->编译->汇编->链接
静态库和动态库均在链接步骤进行处理
静态库会把代码打包进去
动态库 会把位置信息加载，运行程序时 需要去找
静态库制作过程： 预处理->编译->汇编->ar 创建库文件->静态库 libxxxx.a   gcc -l 进行使用
动态库制作过程：预处理->编译->汇编（-fpic/-fPIC）->gcc -shared libxxxx.so
库寻找顺序：虚拟内存 
静态库
	加载速度快
	发布程序无需提供静态库，移植方便
	消耗内存
	更新、部署、发布麻烦
动态库
	实现进程间资源共享
	更新、部署、发布简单
	可以控制何时加载动态库
	加载速度慢
	发布程序时需要提供依赖的动态库

## Makefile
### Makefile作用 
Makefile定义规则来指定哪些文件需要先编译，后编译，重新编译
类似shell脚本，可以执行操作系统的命令
**优点** 在于 自动化编译，整个工程自动编译 Linux GNU的make  

### 原理
先检查规则中的依赖是否存在
	若不存在，向下寻找 能够生成这个依赖的makefile 语句 
	一般Makefile中其他规则 为第一条规则服务

检查更新
	执行规则中命令，会比较目标和依赖文件的时间
	如果依赖时间比目标的时间晚，会重新生成目标
	所以将规则尽可能拆分，更改一个文件，不需要大量的重复编译工作，效率更高
	

### 变量

#### 自定义变量
变量名 = 变量值
#### 预定义变量
	AR: 归档维护程序的名称
	CC ： C 编译器的名称
	CXX : C++编译器的名称
	$@ : 目标的完整名称
	$< : 第一个依赖文件的名称
	$^ : 所有的依赖文件
#### 获取变量的值
	$(变量名)


### GDB调试

GDB 通 GCC 配套组成完整开发工具，是Linux中标准开发环境
	启动程序
	在断点停住
	程序被停，可以检查变量
	可以改变程序

在为调试编译时，会关掉优化选项 ‘-o’, 并打开调试选项 ‘-g’


### 程序和进程
程序包含：
	二进制格式标识
	机器语言指令
	程序入口地址
	数据 
	符号表及重定位表 调试信息
	共享库和动态链接信息
	其他信息
进程
	正在运行的程序的实例
	基本的分配单元，基本的执行单元
	一个程序可以建立多个进程，进程由内核定义的抽象实体
进程组
	一组相关进程的集合
	共享同一进程组标识符（PGID）进程组成，首进程是创建该组的进程，首进程ID为进程组的ID
	进程组开始时间为首进程创建组的时刻，结束时间为最后一个成员进程退出组的时刻
	加入其他进程组也算退出进程组
	首进程无需最后离开进程组
会话
	会话是一组进程组的集合，会话首进程是创建该新会话的进程，进程ID会成为会话ID，
	所有进程共享单个控制终端，控制终端会在会话首进程首次打开一个终端设备时被建立，终端最多可能会成为一个会话的控制终端
	![[Pasted image 20231012111258.png]]
守护进程
	Linux中后台服务进程，采用以d结尾
	inetd httpd
	生命周期长
	后台运行，不拥有控制终端，不会为守护进程自动生成控制信号及终端相关的信号
	步骤
		fork()，父进程退出，子进程继续执行
		子进程调用setsid()开启一个新会话
		清除进程umask以确保当守护进程创建文件和目录时拥有所需的权限
		修改进程的当前工作目录，通常改为根目录
		关闭守护进程从其父进程继承而来的所有打开的文件描述符
		关闭文件描述符0、1、2，打开/dev/null 并使用dup2(）使所有描述符指向该设别
		核心功能
		
单道多道程序
	单道程序，内存只允许一个程序运行
	多道程序，内存中多个相互独立的程序
	多个进程轮流使用CPU
时间片(timeslice)
	操作系统分配给每个正在运行的进程微观上的一段CPU时间，进程看起来像是同时运行的，实则是轮番穿插运行
	由操作系统内核的调度程序分配给每个进程，内核会给每个进程分配相等的初始时间片

#### 并行和并发
并行：同一时刻 多条指令都在运行
并发：宏观上同时执行，微观上，多个进程快速交替运行
#### 进程控制块
内核为每个进程分配一个PCB，task_struct
	进程id
	进程状态
	进程切换时需要保存和恢复的寄存器
	虚拟地址空间信息
	描述控制终端的信息
	当前工作目录
	umask掩码
	文件描述符，指向file结构体的指针
	和信号相关的信息
	用户id和组id
	会话和进程组
	进程可以使用的资源上线


## 进程 的状态
运行：进程占有处理器正在运行 
就绪 ：进程具备运行条件，等待系统分配处理器
阻塞态：又称为等待或睡眠，不具备运行条件，正在等待某个事件的完成

#### 父子进程虚拟地址空间
![[Pasted image 20230911201341.png]]
fork 以后 ，子进程的用户区数据和父进程一样，内核去也会拷贝，但是pid不同
子进程和父进程内存空间有相同的内容，但是内容互不影响
linux中fork是通过写时拷贝，不复制整个进程的地址空间，需要写入时，才会进行，fork之后父子进程共享文件
父子进程对于变量，读时共享，写时拷贝
父进程运行结束子进程未结束，这样的子进程就被称为孤儿进程，内核就把孤儿进程的父进程为init,而init进程会循环wait()它的已经退出的子进程。
进程结束之后，要释放用户区数据，内核区的PCB没有办法自己释放掉，需要父进程释放
进程终止时，父进程尚未回收，子进程残留资源（PCB)存放于内核中，变成僵尸进程，僵尸进程不能被kill -9 杀死
父进程不调用wait()或waitpid()的话，那么保留的那段信息就不会释放，进程号就会被一直占用

## 进程间通讯（IPC : Inner Processes Communication）
### 目的
	数据传输：进程需要将它的数据发送给另一个进程
	通知事件：一个进程需要向另一个或一组进程发送消息，通知发生了某种事件
	资源共享：多个进程共享相同资源，需要提供互斥和同步机制
	进程控制：进程希望完全控制另一个进程的执行，控制进程希望能够拦截另一个进程的所有陷入和异常
### 方式
#### 同一主机
##### Unix进程间通信方式
###### 匿名管道
		- 匿名管道只能在具有公共祖先的进程之间使用
###### 有名管道（FIFO）
提供路径名与之关联，以FIFO的文件形式，存在于文件系统中，并且其打开方式与打开一个普通文件是一样的，这样即使与FIFO 的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO 相互通信，因此，通过FIFO不相关的进程也能交换数据。
一旦打开FIFO，就能与匿名管道和其他文件的系统调用一样，调用，read,write,close。FIFO也有写入和读取端，先入先出。
###### 有名管道注意事项
1. 一个为只读而打开一个管道的进程会阻塞，直到另外一个进程为写打开管道
2. 一个为只写而打开一个管道的进程会阻塞，直到另外一个进程为读打开管道
3. 
###### 管道共有特点
	- 内核内存中维护的缓冲器，存储能力有限
	- 特质：读操作，写操作，匿名管道没有文件实体，有名管道有文件实体，但不存储数据，可以按照操作文
		件的方式对管道进行操作
	- 是一个字节流，不存在消息或消息边界的概念，从管道读取数据的进程可以读取任意大小的数据块，
		而不管写入管道的数据块的大小是多少
	- 半双工，单向，一端写入，一端读取
###### 有名匿名管道区别
1. FIFO作为特殊文件存在，内容却放在内存中
2. 使用FIFO的进程退出后，FIFO文件将继续保存在文件系统中以便以后使用
3. FIFO有名字，不相关进程可以打开进行通信。
##### System V进程间通信方式 Posix进程间通信方式
	消息队列
	共享内存
	信号量

##### 管道的读写特点（有名匿名相同）
使用管道时，注意以下几种特殊情况，假设都是阻塞I/O操作
	- 所有指向管道写端的文件描述符都关闭，管道写端引用计数为0，有进程从管道的读端读数据，那么管道中剩余的数据被读取后，再次read，会返回0
	- 管道写端的文件描述符为>0，而持有管道写端进程也没有往管道中写数据，这个时候，有进程从管道中读取数据，管道中剩余的数据被读取后，再次read会阻塞，直到管道中有数据可以读了，才读取数据并返回。
	- 如果所有指向管道读端的文件描述符为0，管道读端引用计数=0，此时，有进程再往管道中写数据，该进程会受到一个信号SIGPIPE，通常会导致进程异常终止。
	- 如果所有指向管道读端的文件描述符>1,管道读端引用计数>0，此时，持有管道读端的进程，也没有从管道中读数据，此时有进程向管道中写数据，管道中再次write会阻塞，直到管道中有空位置才能再次写入数据并返回。
###### 读管道
	管道中有数据
		read返回实际读到的字节数
	管道中无数据
		写端全部关闭，返回0
		写端没关闭，read阻塞
###### 写管道
	管道读端被关闭，进程终止，收到一个SIGPIPE 
	管道读端未全部关闭，
		管道已满，write阻塞
		管道未满，write写入
有名管道

#### 不同主机
SOCKET
## 内存映射
将磁盘文件映射到内存，通过修改内存就能修改磁盘文件
### 内存映射注意事项
1. 对返回值ptr进行++操作，munmap能否成功
	void\* ptr=void \*mmap(void \*addr,size_t length,int prot,int flags,int fd, off_t offset) 
	ptr++
	munmap(ptr,length);//错误，报错，返回地址需要保存
2. open时，O_RDONLY，mmap时指定为PROT_READ | PROT_WRITE
	错误，返回MAP_FAILED
	open函数中参数建议与PROT参数保持一致
3. 文件偏移量 offset 为1000
	偏移量必须是4k整数倍，会返回MAP_FAILED
4. MMAP调用失败
	length = 0
	PROT
		只指定了写权限
		prot PROT_READ | PROT_WRITE      第五个参数open通过open函数时指定的 O_RDONLY或者O_WRONPY，最好保持一致
5. open的时候通过O_CREAT一个新文件来创建映射区嘛
	可以，但是新文件大小如果为0，不行
	可以对文件进行拓展
		lseek()
		truncate()
6. mmap后关闭文件描述符，对mmap映射产生何影响
	映射区域仍然存在，fd关闭，无影响
7. 对ptr越界操作
	发生段错误

## 信号
信号是linux进程间通信最古老的方式之一，有时也称为软件中断，是在软件层次上对于中断进制的一种模拟，异步通信方式，信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断。
信号在内核中产生，引发内核为进程产生信号的各类事件：
	对于前台进程，用户可以通过输入特殊的终端字符来给他发送信号
	硬件发生异常，即硬件检测到一个错误条件并通知内核，随即由内核发送相应信号给相关进程，诸如被0除，引用了无法访问的内存区域
	系统状态变化，比如alarm定时器到期引起SIGALRM信号
	运行kill命令
### 使用信号的目的
1. 让进程知道发生什么事儿
2. 强迫进程执行自己代码中的信号处理程序
### 信号的特点
简单
不能携带大量信息
满足特定条件才行
优先级比较高
### 查看系统定义的信号列表
kill -l
前31个信号为常规信号，其余为实时信号。
### 信号列表
- 1 SIGHUP 用户退出shell，由该shell启动所有的进程将收到这个信号
- 2 SIGINT CTRL+C组合键，用户终端向正在运行中的由该终端启动的程序发出此信号
- 3 SIGQUIT CTRL+\用户终端发出退出信号
- 9 SIGKILL 无条件终止进程，不能被忽略，
- 11 SIGSEGV 无效内存访问
- 13 SIGPIPE 向一个没有读端的管道写数据
- 17 SIGCHLD 子进程结束，父进程收到
- 18 SIGCONT 进程停止，则使其继续运行
- 19 SIGSTOP 进程停止，信号不能被忽略，处理和阻塞
在应用过程中，使用宏值
#### SIGCHLD信号
产生条件
	子进程终止
	子进程接受到SIGSTOP
	子进程处在停止态，接收到SIGCONT后唤醒
以上都会给父进程发送SIGCHLD信号，父进程默认忽略该信号
### 信号5种默认处理动作
Term 终止进程，默认动作
Ign 当前进程忽略掉这个信号
Core 终止进程，并生成一个Core文件
Stop 暂停当前进程
Cont 继续执行当前被暂停的进程

SIGKILL和SIGTOP不能被捕捉，阻塞或者忽略，只能执行默认动作
### 信号的几种状态
产生，未决，递达
### 信号集
许多信号相关的系统调用都需要能表示一组不同的信号，多个信号可通过一个叫做信号集的数据结构来表示，其系统数据类型为 sigset_t
PCB中有两个非常重要的信号集。一个叫做，“阻塞信号集”，另一个，称之为“未决信号集”。这两个信号集都是内核使用位图机制来实现的。但操作系统不允许我们直接对这两个信号集进行位操作。而需自定义另外一个集合，借助信号集操作函数来对PCB中的这两个信号集进行修改。
信号的“未决”是一种状态，指的是从信号的产生到信号被处理前的一段时间。
信号的“阻塞”是一个开关动作，指的是阻止信号被处理，但不是阻止信号产生。
信号的阻塞就是让系统暂时保留信号留待以后发送。由于另外有办法让系统忽略信号，所以一般情况下信号的阻塞只是暂时的，只是为了防止信号打断敏感的操作。
#### 阻塞信号集和未决信号集
键盘事件CTRL+C
信号产生但是没有被处理，未决
在内核中，将所有没有被处理的信号放在一个集合里
SIGINT信号状态被存储在第二个标志位上
	标志位为0，不是未决状态
	为1，是未决状态
该未决状态信号，需要被处理，与阻塞信号集中的标志位进行比较，如果阻塞信号集中标志位为1，则该信号阻塞（想要阻塞某信号，需要用户调用系统API）

## 程序运行
运行时间 = 内核时间 + 用户时间 + 消耗的时间
文件IO操作比较浪费时间
## 回调函数
程序员实现，提前准备好，函数类型根据实际需求，看函数指针的定义
不是程序员调用，而是当信号产生，由内核调用
函数指针是实现回调的手段，函数实现之后，函数名放到函数指针的位置

## 共享内存
共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段），由于一个共享内存段会称为一个进程用户空间的一部分，因此各种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中，并且这部分数据会对其他所有共享同一个段的进程可用。
与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接受进程将数据从内核内存复制进用户空间的缓冲区的做法相比，这种IPC技术的速度更快。
	1. 操作系统如何知道一块共享内存被多少个进程关联
		共享内存维护了一个结构体struct shmid_ds 这个结构体中有一个成员 shm_nattach
		shm_nattach 记录了关联的进程个数
	2. 可不可以对共享内存进行多次删除 shmct1
		可以的
		因为shmctl标记删除共享内存，不是直接删除
		当和共享内存关联的进程数为0的时候，就真正被删除
		当共享内存key为0的时候，共享内存被标记删除了，如果一个进程和共享内存取消关联，那么该进程不能继续操作这个共享内存，也不能继续进行关联。
	3. 共享内存和内存映射的区别
		- 共享内存可以直接创建，内存映射需要磁盘文件（匿名映射除外）
		- 共享内存效率更高，
		- 所有进程操作的是同一块共享内存，每个进程在自己的虚拟地址空间中有一个独立的内存
		- 进程突然退出，共享内存还存在，内存映射区消失
		- 电脑突然死机，共享内存不存在，内存映射区还存在
		- 进程退出，内存映射区销毁，共享内存还在，需要手动删除，如果一个进程退出，会自动和共享内存取消关联


## 终端
用户通过终端登录系统后得到一个shell进程，这个终端为shell进 程的控制终端，进程中，控制终端是保存在PCB中的信息，而fork()会复制PCB中的信息
默认情况，标准输入，标准输出，标准错误，都指向控制终端 

## 线程
与进程类似，线程是允许应用程序并发执行多个任务。
进程是CPU分配资源的最小单位，线程是操作系统调度执行的最小单位
线程是轻量级的进程（LWP，Light Weight Process），linux环境下线程的本质仍是进程。
查看LWP号： ps -Lf pid
### 与进程区别
进程间信息难以共享，并未共享内存，必须采用进程间通信方式
fork()创建进程代价相对较高，利用写时复制技术，仍需要复制内存页表和文件描述符表之类的多种进程属性，fork()调用在时间上开销较大。
线程能够方便，快速共享信息，只需将数据复制到共享变量中即可
创建线程比创建进程通常要快10倍，线程共享虚拟地址空间。
### 共享资源和非共享资源

![[Pasted image 20231026161512.png]]
### 线程同步
必须确保多个线程不能修改同一变量
临界区是指访问某一共享资源的代码片段，并且这段代码的执行应为原子操作，也就是同时访问同一共享资源的其他线程不应中断该片段的执行
当有一个线程在对内存进行操作时，其他线程不能对这个内存地址进行操作，直到该线程完成操作，其他线程才能对该内存地址进行操作，而其他线程则处于等待状态。
#### 互斥量
同时仅有一个线程能够访问互斥量，保证线程同步，解决安全问题
互斥量仅有两种状态：锁定和非锁定，至多只有一个线程可以锁定该互斥量，再次加锁，可能会出现阻塞或者报错
一旦锁定，该线程成为该变量所有者，每一共享资源（多个共享变量）可能需要多个互斥量解决数据安全问题
	锁定共享资源
	访问共享资源
	解锁

